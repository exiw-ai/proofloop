import asyncio
import json
from pathlib import Path

import typer
from rich.console import Console

console = Console()


def derive_code(
    handoff_path: Path = typer.Argument(
        ...,
        help="Path to derive_payload.json or .proofloop/research directory",
    ),
    workspace: Path = typer.Option(
        None,
        "--workspace",
        "-w",
        help="Target workspace for code generation (default: from handoff)",
    ),
    auto_approve: bool = typer.Option(
        False,
        "--auto-approve",
        "-y",
        help="Auto-approve plan and conditions",
    ),
    baseline: bool = typer.Option(
        False,
        "--baseline",
        help="Run baseline checks before changes",
    ),
    timeout: int = typer.Option(
        60,
        "--timeout",
        "-t",
        help="Timeout in minutes",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Verbose output",
    ),
    state_dir: Path | None = typer.Option(
        None,
        "--state-dir",
        help="State directory",
    ),
) -> None:
    """Derive code implementation from research handoff payload.

    Takes the derive_payload.json generated by research and uses it to
    create a code task with rich context from the research findings.
    """
    asyncio.run(
        derive_code_async(
            handoff_path=handoff_path,
            workspace=workspace,
            auto_approve=auto_approve,
            baseline=baseline,
            timeout=timeout,
            verbose=verbose,
            state_dir=state_dir,
        )
    )


async def derive_code_async(
    handoff_path: Path,
    workspace: Path | None,
    auto_approve: bool,
    baseline: bool,
    timeout: int,
    verbose: bool,  # noqa: ARG001
    state_dir: Path | None,
) -> None:
    """Run code derivation from research handoff."""
    from src.application.dto.task_input import TaskInput
    from src.application.orchestrator import Orchestrator
    from src.cli.formatters.result_formatter import format_result
    from src.cli.formatters.stage_formatter import (
        format_stage_complete,
        format_stage_header,
    )
    from src.cli.formatters.tool_formatter import create_tool_callback
    from src.cli.runner import (
        interactive_clarifications,
        interactive_plan_and_conditions_review,
    )
    from src.infrastructure.agent.claude_agent_adapter import ClaudeAgentAdapter
    from src.infrastructure.checks.command_check_runner import CommandCheckRunner
    from src.infrastructure.git.git_diff_adapter import GitDiffAdapter
    from src.infrastructure.git.repo_root import get_default_state_dir
    from src.infrastructure.persistence.json_task_repo import JsonTaskRepo
    from src.infrastructure.verification.project_analyzer import ProjectAnalyzer

    # Resolve handoff path
    if handoff_path.is_dir():
        # Look for derive_payload.json in the directory
        payload_file = handoff_path / "derive_payload.json"
        if not payload_file.exists():
            payload_file = handoff_path / ".proofloop" / "research" / "derive_payload.json"
    else:
        payload_file = handoff_path

    if not payload_file.exists():
        console.print(f"[red]Handoff payload not found: {payload_file}[/]")
        console.print("[dim]Expected derive_payload.json from research pipeline.[/]")
        raise typer.Exit(1)

    # Load handoff payload
    try:
        payload_data = json.loads(payload_file.read_text(encoding="utf-8"))
    except json.JSONDecodeError as e:
        console.print(f"[red]Invalid JSON in handoff payload: {e}[/]")
        raise typer.Exit(1) from e

    console.print(f"[bold blue]Loading research handoff:[/] {payload_file}")

    # Extract key information
    headline = payload_data.get("headline", "Implement from research")
    goals = payload_data.get("goals", [])
    constraints = payload_data.get("constraints", [])
    recommended_approach = payload_data.get("recommended_approach", "")
    key_findings = payload_data.get("key_findings", [])
    risks = payload_data.get("risks", [])
    workspace_hint = payload_data.get("target_workspace_hint", "")

    # Show summary
    console.print(f"\n[bold]Headline:[/] {headline}")
    console.print(f"[bold]Goals:[/] {', '.join(goals) if goals else 'None specified'}")
    if recommended_approach:
        console.print(f"[bold]Approach:[/] {recommended_approach}")
    console.print(f"[bold]Key findings:[/] {len(key_findings)}")
    if risks:
        console.print(f"[bold]Risks:[/] {len(risks)}")

    # Determine workspace
    if workspace is None:
        if workspace_hint:
            workspace = Path(workspace_hint)
        else:
            console.print("[red]Error: --workspace is required (no hint in payload)[/]")
            raise typer.Exit(1)

    if not workspace.exists():
        console.print(f"[red]Workspace not found: {workspace}[/]")
        raise typer.Exit(1)

    # Build enhanced task description
    description_parts = [headline]
    if recommended_approach:
        description_parts.append(f"\nRecommended approach: {recommended_approach}")

    if key_findings:
        description_parts.append("\n\nKey research findings:")
        for finding in key_findings[:5]:  # Limit to top 5
            summary = finding.get("summary", "")
            if summary:
                description_parts.append(f"- {summary[:200]}")

    if risks:
        description_parts.append("\n\nRisks to consider:")
        for risk in risks[:3]:
            description_parts.append(f"- {risk}")

    enhanced_description = "\n".join(description_parts)

    console.print(f"\n[dim]Workspace: {workspace.absolute()}[/]")

    # Setup state directory
    if state_dir is None:
        state_dir = await get_default_state_dir(workspace)
    state_dir.mkdir(parents=True, exist_ok=True)

    console.print(f"[dim]State dir: {state_dir}[/]")

    # Setup infrastructure
    agent = ClaudeAgentAdapter()
    check_runner = CommandCheckRunner()
    diff_port = GitDiffAdapter()
    task_repo = JsonTaskRepo(state_dir)
    verification_port = ProjectAnalyzer(agent)

    # Create orchestrator
    orchestrator = Orchestrator(
        agent=agent,
        verification_port=verification_port,
        check_runner=check_runner,
        diff_port=diff_port,
        task_repo=task_repo,
        state_dir=state_dir,
    )

    # Create task input with research context
    task_input = TaskInput(
        description=enhanced_description,
        workspace_path=workspace.absolute(),
        sources=[str(workspace.absolute())],
        goals=goals,
        constraints=constraints,
        auto_approve=auto_approve,
        baseline=baseline,
        timeout_minutes=timeout,
    )

    # Set callbacks
    plan_conditions_callback = None if auto_approve else interactive_plan_and_conditions_review
    clarification_callback = None if auto_approve else interactive_clarifications
    tool_callback = create_tool_callback(console, cwd=str(workspace.absolute()))

    def stage_callback(name: str, is_starting: bool, duration: float) -> None:
        """Display stage progress."""
        if is_starting:
            format_stage_header(console, name)
        else:
            format_stage_complete(console, name, duration)

    # Run pipeline
    try:
        result = await orchestrator.run(
            task_input,
            plan_and_conditions_callback=plan_conditions_callback,
            clarification_callback=clarification_callback,
            on_agent_message=tool_callback,
            on_stage=stage_callback,
        )

        # Display result
        format_result(console, result)

    except Exception as e:
        from loguru import logger

        logger.exception("Derive-code task failed")
        console.print(f"[bold red]Error:[/] {e}")
        raise typer.Exit(1) from e
